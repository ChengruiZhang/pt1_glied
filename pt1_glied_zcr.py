import numpy as np
import time
import math
import matplotlib.pyplot as plt

try:
    # get monotonic time to ensure that time deltas are always positive
    _current_time = time.monotonic
except AttributeError:
    # time.monotonic() not available (using python < 3.3), fallback to time.time()
    _current_time = time.time
    # warnings.warn('time.monotonic() not available in python < 3.3, using time.time() as fallback')


class TurboEngine():

    def __init__(self, current_action, action_space_dim=1, time_constant=1/1, gain=1, steps_action_history_length=10):
        self.T = time_constant  # t = 1/f; video game f = 30Hz
        self.K = gain
        # self.K = delta_y / delta_e
        self.a = np.zeros(action_space_dim)  # idling engines at start
        self.last_time = None
        # self.output_limits=(-1,1) # set action_limit in ddpg

    def pt1_glied(self, next_a, dt, time_step=1e-4):
        # input:
        # next_a: new action generated by policy (SAC/DDPG)
        #
        # output: updated action through PT1 controller which goes into the Lunar Lander environment
        # utilizes action history from TurboEngine class

        # https://de.wikipedia.org/wiki/PT1-Glied
        # print(dt)
        error = next_a - self.a
        # response = (1-math.exp(dt/self.T))*error*self.T
        response = time_step/(self.T + time_step)*error
        self.a = self.a + response

        # # ToDo update action history in class
        # self.y_n_min_1 = y_n
        return self.a

    def reset(self):
        self.a = 0.0  # idling engines at start

if __name__ == '__main__':
    TE = TurboEngine(-1)
    start_time = time.time()
    # keep track of values for plotting
    setpoint, y, x = [], [], []
    TE.last_time = _current_time()
    # time passed

    while time.time() - start_time < 4:
        current_time = _current_time()
        dt = current_time - TE.last_time
        current_time = time.time()
        current_a = TE.pt1_glied(1, dt)

        x += [current_time - start_time]
        y += [current_a]
        setpoint += [1]

    # update time to now
    TE.last_time = _current_time()

    while time.time() - start_time < 8:
        current_time = _current_time()
        dt = current_time - TE.last_time
        current_time = time.time()
        current_a = TE.pt1_glied(-1, dt)

        x += [current_time - start_time]
        y += [current_a]
        setpoint += [-1]

    # update time to now
    TE.last_time = _current_time()


    plt.plot(x, y, label='measured')
    plt.plot(x, setpoint, label='target')
    plt.xlabel('time')
    plt.ylabel('temperature')
    plt.legend()
    plt.show()